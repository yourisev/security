# Authentication API
Created a simple authentication API to understand the flow of this process and test on Postman.

The image below shows an attempt to use the authenticate endpoint of our endpoint with a non existing user,
notice the 403 code.
![Auth-Failed](https://github.com/yourisev/security/assets/69630866/f162a65c-4562-42b5-8fc0-4f62f189e19b)

Just to show the previous image is right we can see that our Postgres DB is empty on the image below.
![image](https://github.com/yourisev/security/assets/69630866/698f328d-29d7-4db4-8435-7997feb308b3)

The image below shows that the user with credentials in the body of the request is successfullly registered,
notice the 200 code.
![image](https://github.com/yourisev/security/assets/69630866/c2de43ca-dc63-420a-b2f6-7bfdceda38b4)

The image below shows how the DB is populated after we sent the above request to registration endpoint.
![image](https://github.com/yourisev/security/assets/69630866/3891f691-f66e-438c-8fa5-80a4bbb0c9cc)

We then authenticate using the credentials registered previously and notice the request is succesful and
we are given a token just as it was the case with the registration process and a code of 200 is generated.
![image](https://github.com/yourisev/security/assets/69630866/47282c5f-19f7-40cb-b966-76da2de2bd86)

We then try to access a secured end point using a token that was not generated by the system and we equally have a 403
code.
![Bad-token-test](https://github.com/yourisev/security/assets/69630866/f17d9ff7-585e-413b-819f-769184217567)

We finally pass a non expired token generated when trying to register above an we notice this access is successful with
a 200 code.
![image](https://github.com/yourisev/security/assets/69630866/6a287327-d297-4e59-8e6d-5ea323b7d271)

## ~Tech Stack
+ Java
+ Spring Boot
+ Spring JPA
+ Spring Security
+ PostgreSQL

## Description
### User Model
A User class is created and __lombok__ is used to inject boiler plate code for getters/setters, contructors and is made to use the builder pattern. This class is equally made to be an Entity and an Id is added as attribute to the class and given a table name. Further this class is made to implement the [UserDetails Interface ](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetails.html). The **_user** table is created on the fly each time the app is started (This is configured in the properties file with __create-drop__ value). A UserRepository is created and a method findByEmail is added to retrieve users in the DB using their emails. We equally created an Enum Role for the different user roles anticipated.
### Secured Endpoint
Two Rest Controllers were created and one is assigned to an endpoint that could only be accessed if there is a valid authorization token present in the request __DemoController__. 
### Public Endpoint
On the other side, __AuthenticationController__ has two methods that each take in a RegisterRequest and an AuthenticationRequest and both return an AuthenticationResponse. The return type of the both methods in the previously mentioned controller were defined for this project also their request body. A model was again created to match the potential view for the registration end point. 
### Services
A __JwttService__ (Service) class was created to handle the creation of the __JWT__ token and extraction of data from it(username, expiration date). The class mentioned here contains a _SECRET KEY_ used to sign the JWT token and ensure the message was not changed along the way. An __AuthenticationService__ that contained methods to register and authenticate users. Both methods returned a token encapsulated into onbject of the class __AuthenticationResponse__ defined.
### Configuration
A class __JwtAuthenticationFilter__ that extends the class [OncePerRequestFilter](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/OncePerRequestFilter.html) was created. This class overrides the __doFilterInternal__ so that if the [SecurityContextHolder](https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html) holds the user as been authenticated it should not be done again. Also a class __ApplicationConfig__ was created to define all the beans that need to be injected at run time. Finally we have a __SecurityConfiguration__ class that configures the [SecurityFilterChain](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html) to prevent CSRF attacks, allows access to all endpoints whose path matches _/api/v1/auth/**_ and require authentication for all others.
